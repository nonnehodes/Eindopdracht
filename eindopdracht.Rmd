---
title: "Eindopdracht"
author: "Willemijn Meijer en Nonne Hodes"
date: "7-4-2023"
output: html_document
---

# _Opdracht 1: Het schrijven van een korte introductie over het onderzoek_

## __introductie__
__Achtergrondinformatie__ Er zijn veel verschillende hersenziekten die ontstaan door de verstoorde functie van hersencellen. Voor onderzoek op moleculair niveau wil je het liefst gezonde hersencellen vergelijken met hersencellen van een zieke patient. Om een specifiek celltype te kunnen ontwikkelen voor onderzoek kunnen fibroblasten uit de huid worden omgezet tot een geinduceerde pluripotente stamcel. Deze stamcellen kunnen weer tot ieder celltype worden gedifferenteerd, in dit geval dus tot hersencellen. Tijdens dit onderzoek wordt er juist een andere methode gebruikt; transdifferentiatie. Bij deze methode wordt er veel tijd bespaard doordat er niet eerst iPSC worden ontwikkeld, maar de fibroblasten direct worden omgezet tot, in dit geval, de te onderzoeken hersencellen. De fibroblasten zijn bij dit onderzoek afkomstig uit één proefpersoon. Waarbij de controlegroep fibroblasten wordt behandeld met het transcriptiefactor BCLXL en de andere groep fibroblasten met de transcriptiefactor ONECUT3. Bij deze methode worden de transcriptiefactoren tot overexpressie gebracht waardoor de cellen van identiteit kunenn veranderen. __Doelstelling:__ Het doel van dit onderzoek is om te achterhalen of er verschil zit in genexpressie tussen fibroblasten die behandeld zijn met BCLXL of cellen die behandeld zijn met ONECUT3. __De onderzoeksvraag__ hierbij luidt: "Wat zijn de verschillen in genexpressie tussen BCLXL behandelde cellen en ONECUT3 behandelde cellen?" __Verwachting__ Er wordt verwacht dat de behandeling met de transcriptiefactor ONECUT3, ervoor kan zorgen dat de fibroblasten van identiteit kunnen veranderen en op die manier om kunnen worden gezet tot hersencellen.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r packages, echo=FALSE}
#Alle benodigde packages worden alvast geladen
library(tidyverse)
library(Rsubread)
library(ggplot2)
library(dslabs)
library(dplyr)
library(pheatmap)
library(DESeq2)
library(GO.db)
library(GOstats)
library(png)
library(grid)
library(gridExtra)
```

# _Opdracht 2: Het bekijken van de fastQC hmtl rapporten en hieruit conclusies trekken_
Wanneer er naar de verschillende fastQC hmtl rapporten wordt gekeken dan is er te zien dat de kwaliteit over het algemeen goed is. We zijn voor de RNA-sequencing voornmamelijk geinteresseerd in de kwaliteit van per base en de kwaliteit per sequence. De andere resultaten gebruiken we niet bij de analyse voor de RNA-sequencing omdat deze voornamelijk op de DNA-sequentie gericht zijn. 
Er is te zien dat bij alle fastQC rapporten er een gemiddelde Phred-score is van ongeveer 35. De Phred-score geeft de maat aan voor de kwaliteit van de identificatie van de nucleotidenbasen bij DNA/RNA-sequencing. Een Phred-score van 35 geeft aan dat de identificatie redelijk nauwkeurig is. (99,9% nauwkeurigheid)
Om een duidelijker beeld te scheppe waar de waarnemingen en conclusies over de fastQC bestanden op zijn gebasseerd zijn er twee afbeeldingen weergegeven waarin in de en eafbeelding de forward reads, en in de andere afeelding de reverse reads zijn weergegeven. 

_Dit is op de volgende manier uitgevoerd_

```{r Voorbeeld FastQC hmtl rapport, echo=FALSE, fig.height=4, out.width= '100%', fig.cap= "Figuur 1: Een voorbeeld van de kwaliteit per base, verkregen uit de fastqc hmtl rapporten. Met op de y-as de Phred-score weergegeven die oploopt van 0-36. De kwaliteit van deze voorbeeldsequenties is hoog, er is een gemiddelde Phred-score van 35. } 
#Het importeren van een fastQC rapport om een beeld te scheppen waar de conclusies op zijn gebasseerd.
#Er wordt een vector gemaakt van de afbeeldingen dmv een readPNG, de functie rasterGrob zorgt ervoor dat de afbeelding zo in een raster wordt geplaatst hoe jij het aangeeft (de gewenste locatie, grootte en orientatie van de afbeelding kan worden opgegeven)
fastqc_SRR7866699_1 <- rasterGrob(as.raster(readPNG("fastqc_kwaliteit_per_base_SRR7866699_1.png")))
fastqc_SRR7866699_2 <- rasterGrob(as.raster(readPNG("fastqc_kwaliteit_per_base_SRR7866699_2.png")))
#nu kunnen deze twee afbeeldingen samen worden gevoegd in een raster dmv de functie grid.arrange
grid.arrange(fastqc_SRR7866699_1, fastqc_SRR7866699_2, ncol=2, top=textGrob("De kwaliteit per base analyse voor de forward(links) en reverse(rechts) read")
```

Bij de linker afbeelding is er te zien dat de Phred-score (de horizontale blauwe lijn) bij de eerste 3 basen wat lager is, hier is de identificatie van de basen dus iets minder nauwkeurig dan hoe dit is voor de basen 4-40. De errorbars geven in deze afbeelding aan dat er wel wat variatie zit in de kwaliteitsscore. Deze variatie is bij de eerste base en de laatste 6 basen het grootst. Bij de laatste base komt de variatie zelfs in het rode gedeelte wat aangeeft dat deze kwaliteitscore erg gevarieerd is. Maar de gemiddelde Phred-score blijft bij de gehele sequentie binnen het groen gebied, wat dus aangeeft dat de kwaliteit goed is voor verdere analyse. 

__Opdracht 3: Een code schrijven voor het generen van de count table waarbij gebruik wordt gemaakt van het Rsubread package__

```{r count table, eval=FALSE}
#Voor het maken van een count table moeten we eerst een object aanmaken wat als input directory wordt gezien --> de input files zijn de bam files en daarna wordt dus verwezen met het path

input_directory <- "/home/daur2/rnaseq/rnaseq_onecut/bam/"
#onze inpur_directory bevat nu het path naar alle bamfiles die in de map bam staan. We moeten hierin nog een selectie maken van de bamfiles die voor de analyse,   gebruikt moeten worden --> SRR7866699, SRR7866700, SRR7866705, SRR7866706 
input_bam_files <- list.files(path= input_directory, pattern= ".*[9056]\.bam$", full.names= TRUE)

#we willen natuurlijk ook een directory creeeren waar de output van de count table in komt, in de map van de counts staan meerdere reads bestanden, maar we willen het bestand waar alle 
counts_directory <- "/home/daur2/rnaseq/rnaseq_onecut/counts/read_counts.rds"

#voor het tellen van de reads per gen wordt er gebruik gemaakt van de functie featureCounts. Hierbij wordt er achterhaald hoevaak de reads overeenkomen met het menselijke regerentiegenoom. DE genomische locaties staan in de ingebouwde annotatiebestanden. 
read_counts <- featureCounts(files= input_bam_files, annot.inbuilt = "hg38", useMetaFeatures= TRUE, strandSpecific = 1, isPairedEnd= TRUE, countReadPairs= TRUE, nthreads= 10)
```

__Opdracht 4: Er wordt een DEseq2 object gemaakt aan de hand van de count table met de informatie uit de csv bestanden__
#we gebruiken de al gegenereerde count table read_counts_OC3.rds

```{r count tabel}
#Allereerst zorgen we dat we de al gegenereerde count table in een vector plaatsen
count_tabel <- readRDS("/home/daur2/rnaseq/rnaseq_onecut/counts/read_counts_OC3.rds") 

#Voordat we het DESeq object kunnen maken hebben we de telmatrix nodig uit de al gegenereerde count table
telmatrix <- count_tabel$counts

#We gebruiken de bekende sample informatie die al op de server aanwezig was; onecut_sampledata_OC3.csv
sample_data <- read_csv("/home/daur2/rnaseq/rnaseq_onecut/onecut_sampledata_OC3.csv")

#we maken van deze sample data nu een dataframe
sample_data_frame <- as.data.frame(sample_data)

#we maken ons dataframe overzichterlijker door als rowname de naam van de bamfiles te gebruiken.
rownames(sample_data_frame) <- paste0(sample_data_frame$Run, ".bam")

#Voordat we een DESeq kunnen uitvoeren moet er gekeken worden of de rijnamen van de sampledata overeenkomen met de kolomnamen van de telmatrix. 
colnames(telmatrix) == rownames(sample_data_frame)
#hieruit komt TRUE, wat dus aangeeft dat de colnames en de rownames inderdaad overeenkomen, dus de data verder gebruikt kan worden voor het maken van het DESeq-object

#We maken een nieuwe kolom aan in ons dataframe die aangeeft welke behandeling de cellen hebben gehad
#code from: https://sparkbyexamples.com/r-programming/replace-string-with-another-string-in-r/#:~:text=Use%20str_replace_all()%20method%20of,be%20replaced%20on%20work_address%20column.

replace_string <- c("Skin derived fibroblast overexpressing Bclxl" = "BCLXL", "2 days after induction of OC3 in skin derived fibroblasts" = "ONECUT3")
sample_data_frame_2 <- sample_data_frame %>% mutate(Behandeling= str_replace_all(Cell_type, replace_string))

#We maken nu van de nieuw gemaakte kolom een factor, omdat dit nodig is voor het maken van een DESeq object. De levels worden zo ingesteld dat de behandeling kan worden vergeleken met de controle, nu kan er dus worden gekeken in hoeverre de genexpressie is veranderd ten iopzichte van de controlesituatie. Hiervoor wordt dus als eerste level voor de controle behandeling, BCLXL gekozen.
sample_data_frame_2$Behandeling <- sample_data_frame_2$Behandeling %>% factor(levels = c("BCLXL", "ONECUT3"))

#Er kan nu een DeSeq-object worden gemaakt van het dataframe, hiervoor hebben we het pakket library(DESeq2) al eerder geladen. Er wordt hierbij gebruik gemaakt van de functie DESeqDataSetFromMatrix omdat er gebruik wordt gemaakt van onze teltabel als matrix, waar de fragmenttellingen voor elk gen per monster in staan
DESeq_onecut <- DESeqDataSetFromMatrix(
  countData = telmatrix,
  colData = sample_data_frame_2, 
  design = ~ Behandeling
)
```

__Opdracht 5: Er wordt een PCA analyse uitgevoerd__

```{r PCA}
#allereerst wordt de data uit de DESeq object genormaliseerd. Dit wordt de gedaan aan de hand van de rlog functie. Deze functie tranformeert de telgegevens naar de log2-schaal. Dit is nodig voor de normalisatie van mogelijke uitschieters. De output van de rlog is een SumarizedExperiment-object

DESeq_onecut_rlog <- rlog(DESeq_onecut)

#aan de hand van deze genormaliseerde dataset kan er een PCA analyse worden uitgevoerd.



```





__Opdracht 6: Er wordt een DGE analyse uitgevoerd op het DESeq-object__


```{r DGE analyse}
#er wordt een DGE analyse uitgevoerd met behulp van de DESeq functie, hierbij wordt gebruik gemaakt van de niet-genormaliseerde data van het DESeq-object. We specificeren de results functie op een p-waarde van 0.01 en een LFC van 1


DGE_onecut <- DESeq(DESeq_onecut)

#de resultaten van de DGE analyse zijn vervolgens te bekijken met de functie results()
DGE_onecut_resultaten <- results(DGE_onecut, alpha= 0.01, lfcThreshold= 1)
summary(DGE_onecut_resultaten)

#er zijn 661 genen upgereguleerd en 644 genen downgereguleerd
```

```{r Volcano plot}

#nu kunnen we de resultaten van de DGE-analyse visualiseren door deze in een Volcano plot weer te geven. Hierbij is er een adjusted p-value < 0.01 en een LFC > 1. De kleur van de genen die voldoen aan deze voorwaarden worden donkeroranje gekleurd
#er wordt een dataframe gemaakt van de resultaten uit de DGE analyse waarbij de genen die geen adjuste P waarde bevatten worden verwijderd.

DGE_onecut_volcanoplot <- data.frame(DGE_onecut_resultaten) %>% filter(!is.na(padj))

#we willen vervolgens aangeven welke genen wel of niet significant zin, daarom maken we een kolom die aangeeft als de adjuste pwaarde kleiner is dan 0.01, deze significant is. En wanneer de LFC > 1 dat deze dan significant is. Anders wordt het aangegeven als niet significant.

DGE_onecut_volcanoplot <- DGE_onecut_volcanoplot %>% mutate(significantie= if_else(padj < 0.01 & abs(log2FoldChange) > 1, "Significant", "Niet Significant"))


#Er wordt een Volcano plot gegenereerd door de plot functie geom_point, daarbij wordt er een donker oranje kleur gegeven aan de genen die significant zijn. De LFC en de p-waarde worden aangegeven met een stippellijn


DGE_onecut_volcanoplot %>% ggplot(aes(x= log2FoldChange, y= -log10(padj), color= significantie)) + geom_point() + 
xlab("Log2 Fold change") +
ylab("-log10 adjuste p-waarde") +

scale_colour_manual(values= c("grey", "darkorange"), name= "significantie") + 
 geom_hline(yintercept = -log10(0.01), linetype = "dashed") +
  geom_vline(xintercept = 1, linetype = "dashed") +
  geom_vline(xintercept = -1, linetype = "dashed") +
annotate("text", x=10, y= 200, label= "Upgereguleerde genen= 661")+ 
annotate("text", x=-4, y=200, label="Downgereguleerde genen=644")
```
